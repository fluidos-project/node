// Copyright 2022-2024 FLUIDOS Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package v1alpha1

import (
	"encoding/json"
	"fmt"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/klog/v2"
)

// Phase represents the phase of the solver.
type Phase string

// PhaseStatus represents the status of a phase of the solver. I.e. the status of the REAR phases.
type PhaseStatus struct {
	Phase          Phase  `json:"phase"`
	Message        string `json:"message,omitempty"`
	StartTime      string `json:"startTime,omitempty"`
	LastChangeTime string `json:"lastChangeTime,omitempty"`
	EndTime        string `json:"endTime,omitempty"`
}

// Selector defines the constraints of the flavor that the solver is looking for.
// The FlavorType is compulsory, while the Filters are optional.
type Selector struct {
	// FlavorType is the type of the Flavor that the solver is looking for.
	FlavorType FlavorTypeIdentifier `json:"flavorType"`

	// Filters contains the filters that the solver is using to refining the research.
	Filters *runtime.RawExtension `json:"filters,omitempty"`
}

// SolverSpec defines the desired state of Solver.
type SolverSpec struct {

	// Selector contains the flavor requirements for the solver.
	Selector *Selector `json:"selector,omitempty"`

	// IntentID is the ID of the intent that the Node Orchestrator is trying to solve.
	// It is used to link the solver with the intent.
	IntentID string `json:"intentID"`

	// FindCandidate is a flag that indicates if the solver should find a candidate to solve the intent.
	FindCandidate bool `json:"findCandidate,omitempty"`

	// ReserveAndBuy is a flag that indicates if the solver should reserve and buy the resources on the candidate.
	ReserveAndBuy bool `json:"reserveAndBuy,omitempty"`

	// EstablishPeering is a flag that indicates if the solver should enstablish a peering with the candidate.
	EstablishPeering bool `json:"establishPeering,omitempty"`
}

// SolverStatus defines the observed state of Solver.
type SolverStatus struct {

	// FindCandidate describes the status of research of the candidate.
	// Rear Manager is looking for the best candidate Flavor to solve the Node Orchestrator request.
	FindCandidate Phase `json:"findCandidate,omitempty"`

	// ReserveAndBuy describes the status of the reservation and purchase of selected Flavor.
	// Rear Manager is trying to reserve and purchase the resources on the candidate FLUIDOS Node.
	ReserveAndBuy Phase `json:"reserveAndBuy,omitempty"`

	// Peering describes the status of the peering with the candidate.
	// Rear Manager is trying to establish a peering with the candidate FLUIDOS Node.
	Peering Phase `json:"peering,omitempty"`

	// DiscoveryPhase describes the status of the Discovery where the Discovery Manager
	// is looking for matching flavors outside the FLUIDOS Node
	DiscoveryPhase Phase `json:"discoveryPhase,omitempty"`

	// ReservationPhase describes the status of the Reservation where the Contract Manager
	// is reserving and purchasing the resources on the candidate node.
	ReservationPhase Phase `json:"reservationPhase,omitempty"`

	// ConsumePhase describes the status of the Consume phase where the VFM (Liqo) is enstablishing
	// a peering with the candidate node.
	ConsumePhase Phase `json:"consumePhase,omitempty"`

	// SolverPhase describes the status of the Solver generated by the Node Orchestrator.
	// It is useful to understand if the solver is still running or if it has finished or failed.
	SolverPhase PhaseStatus `json:"solverPhase,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// Solver is the Schema for the solvers API
// +kubebuilder:printcolumn:name="Intent ID",type=string,JSONPath=`.spec.intentID`
// +kubebuilder:printcolumn:name="Find Candidate",type=boolean,JSONPath=`.spec.findCandidate`
// +kubebuilder:printcolumn:name="Reserve and Buy",type=boolean,JSONPath=`.spec.reserveAndBuy`
// +kubebuilder:printcolumn:name="Peering",type=boolean,JSONPath=`.spec.establishPeering`
// +kubebuilder:printcolumn:name="Candidate Phase",type=string,priority=1,JSONPath=`.status.findCandidate`
// +kubebuilder:printcolumn:name="Reserving Phase",type=string,priority=1,JSONPath=`.status.reserveAndBuy`
// +kubebuilder:printcolumn:name="Peering Phase",type=string,priority=1,JSONPath=`.status.peering`
// +kubebuilder:printcolumn:name="Status",type=string,JSONPath=`.status.solverPhase.phase`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.solverPhase.message`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +kubebuilder:resource:shortName=sol
// Solver is the Schema for the solvers API.
type Solver struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   SolverSpec   `json:"spec,omitempty"`
	Status SolverStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// SolverList contains a list of Solver.
type SolverList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Solver `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Solver{}, &SolverList{})
}

// ParseSolverSelector is a utility function that extracts the SolverTypeIdentifier and the SolverTypeData from the Solver.
// It provides a set of validation for nested data, so the nested filters, if present, are validated as well.
// ATTENTION: This function can return a nil interface{} if the SolverTypeData is not present.
func ParseSolverSelector(s *Selector) (FlavorTypeIdentifier, interface{}, error) {
	switch s.FlavorType {
	case TypeK8Slice:
		var k8sliceFilter K8SliceSelector
		klog.Info("Parsing K8Slice selector")
		if s.Filters == nil {
			klog.Info("No specific filters found")
			return TypeK8Slice, nil, nil
		}
		if err := json.Unmarshal(s.Filters.Raw, &k8sliceFilter); err != nil {
			return "", nil, err
		}

		// Parse the filters
		filters, err := ParseK8SliceSelector(&k8sliceFilter)
		if err != nil {
			return "", nil, err
		}
		klog.Infof("K8Slice Selector owns %d filters", len(filters))

		return TypeK8Slice, k8sliceFilter, nil
	case TypeVM:
		// TODO (VM): implement the VM selector parsing
		return "", nil, fmt.Errorf("solver type %s not supported", s.FlavorType)
	case TypeService:
		var serviceFilter ServiceSelector
		klog.Info("Parsing Service selector")
		if s.Filters == nil {
			klog.Info("No specific filters found")
			return TypeService, nil, nil
		}
		if err := json.Unmarshal(s.Filters.Raw, &serviceFilter); err != nil {
			return "", nil, err
		}

		// Parse the filters
		filters, err := ParseServiceSelector(&serviceFilter)
		if err != nil {
			return "", nil, err
		}
		klog.Infof("K8Slice Selector owns %d filters", len(filters))

		return TypeService, serviceFilter, nil

	case TypeSensor:
		// TODO (Sensor): implement the Sensor selector parsing
		return "", nil, fmt.Errorf("solver type %s not supported", s.FlavorType)
	default:
		return "", nil, fmt.Errorf("solver type %s not supported", s.FlavorType)
	}
}
